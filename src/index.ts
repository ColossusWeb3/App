import { app, BrowserWindow, ipcMain } from 'electron';
import { OpenAI } from 'openai';
import fs from 'fs';
import path from 'path';
import axios from 'axios';
import https from 'https';

require('dotenv').config()

// Initialize OpenAI
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
})


// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    height: 800,
    width: 1200,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

// Handle app prompt requests
ipcMain.handle('generate-app', async (event, prompt) => {
  try {
    // Get the app design and logic from OpenAI
    const appSpec = await generateAppFromPrompt(prompt);

    // Create a temporary directory for the app
    const appDir = path.join(app.getPath('temp'), `app-${Date.now()}`);
    fs.mkdirSync(appDir, { recursive: true });

    // Write app files
    fs.writeFileSync(path.join(appDir, 'app.js'), appSpec.logic);
    fs.writeFileSync(path.join(appDir, 'app.css'), appSpec.styles);
    fs.writeFileSync(path.join(appDir, 'app.html'), appSpec.html);

    return {
      success: true,
      appPath: appDir,
      appData: appSpec
    };
  } catch (error) {
    console.error('Error generating app:', error);
    return {
      success: false,
      error: error.message
    };
  }
});

const updatedSystemPrompt = `You are an expert UI/UX designer and developer who creates futuristic mini-applications.
Create a fully functional mini-app based on the user's request.
Return a JSON object with three properties:
1. html: The HTML structure of the app
2. styles: CSS styles for the app (with futuristic design elements)
3. logic: JavaScript code that implements the app's functionality

Your app should be visually striking with a futuristic aesthetic. Use modern CSS features
like glassmorphism, gradients, and subtle animations. The app should be fully functional
and should work within an Electron environment.
`;

// Function to generate app from prompt using OpenAI
async function generateAppFromPrompt(prompt: string) {
  const completion = await openai.chat.completions.create({
    model: "gpt-4-turbo",
    messages: [
      {
        role: "system",
        content: updatedSystemPrompt
      },
      {
        role: "user",
        content: prompt
      }
    ],
    temperature: 1.5,
    max_completion_tokens: 4000,
    response_format: { type: "json_object" }
  });

  console.log(completion.choices[0].message.content)

  return JSON.parse(completion.choices[0].message.content);
}

// Load and run the generated app - EMBEDDED ONLY VERSION
ipcMain.handle('run-app', (event, appPath) => {
  // We don't create a new window here anymore
  // Just return the app data so it can be displayed in the main window
  const htmlPath = path.join(appPath, 'app.html');
  const cssPath = path.join(appPath, 'app.css');
  const jsPath = path.join(appPath, 'app.js');

  try {
    const html = fs.readFileSync(htmlPath, 'utf8');
    const styles = fs.readFileSync(cssPath, 'utf8');
    const logic = fs.readFileSync(jsPath, 'utf8');

    return {
      success: true,
      appData: { html, styles, logic }
    };
  } catch (error) {
    console.error('Error loading app files:', error);
    return { success: false, error: error.message };
  }
});
// Add network request handlers for embedded apps
// Handler for fetch API requests from embedded apps
ipcMain.handle('app-fetch', async (event, url, options = {}) => {
  try {
    console.log(`Fetch request to: ${url}`);

    // Use axios for the actual request since it's more robust in Node.js environment
    const response = await axios({
      url: url,
      method: options.method || 'GET',
      headers: options.headers || {},
      data: options.body ? JSON.parse(options.body) : undefined,
      params: options.params,
      responseType: 'text',
      httpsAgent: new https.Agent({
        rejectUnauthorized: true // Enforce SSL verification
      })
    });

    // Try to parse response as JSON if possible
    let parsedData;
    try {
      parsedData = JSON.parse(response.data);
    } catch (e) {
      parsedData = response.data;
    }

    return {
      ok: response.status >= 200 && response.status < 300,
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
      data: parsedData,
      url: response.config.url
    };
  } catch (error) {
    console.error('Error in app-fetch:', error.message);
    return {
      ok: false,
      status: error.response?.status || 0,
      statusText: error.message,
      error: true,
      message: error.message
    };
  }
});

// Handler for more complex axios-like requests from embedded apps
ipcMain.handle('app-request', async (event, config) => {
  try {
    console.log(`Request to: ${config.url}`);

    // Create custom axios instance with ability to ignore SSL issues if needed
    const axiosInstance = axios.create({
      httpsAgent: new https.Agent({
        rejectUnauthorized: config.rejectUnauthorized !== false
      })
    });

    const response = await axiosInstance(config);

    return {
      success: true,
      status: response.status,
      statusText: response.statusText,
      headers: response.headers,
      data: response.data,
      config: response.config
    };
  } catch (error) {
    console.error('Error in app-request:', error.message);
    return {
      success: false,
      error: true,
      status: error.response?.status || 0,
      statusText: error.response?.statusText || error.message,
      message: error.message,
      code: error.code
    };
  }
});